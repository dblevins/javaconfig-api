JSR 354 Money and Currency -- Specification
===========================================
:title: JSR 354 (Money & Currency) - Specification
:jsrnumber: XXX
:revnumber: 0.1-SNAPSHOT
:revremark: Early Draft Review
:revdate: December 2014
:longversion: {revnumber} ({revremark}) {revdate}
:authorinitials: ATR
:author: Anatole Tresch, Credit Suisse
:email: <anatole.tresch@credit-suisse.com>
:source-highlighter: coderay
:website: http://java-config.org/
:iconsdir: {imagesdir}/icons
:toc:
:toc-placement: manual
:icons:
:encoding: UTF-8
:title: JSR {{jsrnumber}} Java EE Configuration - Specification
:numbered:

'''

<<<

-> add image : : https://raw.githubusercontent.com/JavaConfig/config-api/master/src/main/asciidoc/images/javaconfig.jpg[]

toc::[]

<<<
:numbered!:

*EVALUATION LICENCE*

*JSR-000354 Money and Currency API 1.0 Public Review*

CREDIT SUISSE AG IS WILLING TO LICENSE THIS SPECIFICATION TO YOU ONLY
UPON THE CONDITION THAT YOU ACCEPT ALL OF THE TERMS CONTAINED IN THIS
LICENSE AGREEMENT ("AGREEMENT"). PLEASE READ THE TERMS AND CONDITIONS
OF THIS AGREEMENT CAREFULLY. BY DOWNLOADING THIS SPECIFICATION, YOU
ACCEPT THE TERMS AND CONDITIONS OF THIS AGREEMENT. IF YOU ARE NOT
WILLING TO BE BOUND BY THEM, SELECT THE "DECLINE" BUTTON AT THE
BOTTOM OF THIS PAGE AND THE DOWNLOADING PROCESS WILL NOT CONTINUE.


Specification: JSR-{{jsrnumber}} Java EE Configuration ("Specification")+
Version: {revnumber}+
Status: {revremark}+
Release: {revdate}+
Copyright 2013-2014 Credit Suisse AG, Oracle Corp+
8070 Zurich, Switzerland+
All rights reserved.+

*NOTICE*

The Specification is protected by copyright and the information
described therein may be protected by one or more U.S. patents,
foreign patents, or pending applications. Except as provided under
the following license, no part of the Specification may be
reproduced in any form by any means without the prior written
authorization of Credit Suisse AG ("the Specification Lead") and its
licensors, if any. Any use of the Specification and the information
described therein will be governed by the terms and conditions of
this Agreement.

Subject to the terms and conditions of this license, including your
compliance with Paragraphs 1 and 2 below, the Specification Lead
hereby grants you a fully-paid, non-exclusive, non-transferable,
limited license (without the right to sublicense) under the
Specification Lead's intellectual property rights to:

1. Review the Specification for the purposes of evaluation. This
includes:
(i)   developing implementations of the Specification for your
      internal, non-commercial use;
(ii)  discussing the Specification with any third party; and
(iii) excerpting brief portions of the Specification in oral or
      written communications which discuss the Specification
      provided that such excerpts do not in the aggregate
      constitute a significant portion of the Technology.

2. Distribute implementations of the Specification to third parties
   for their testing and evaluation use, provided that any such
   implementation:
(a) does not modify, subset, superset or otherwise extend the
    Licensor Name Space, or include any public or protected packages,
    classes, Java interfaces, fields or methods within the Licensor
    Name Space other than those required/authorized by the
    Specification or Specifications being implemented;
(b) is clearly and prominently marked with the word "UNTESTED" or
    "EARLY ACCESS" or "INCOMPATIBLE" or "UNSTABLE" or "BETA" in
    any list of available builds and in proximity to every link
    initiating its download, where the list or link is under
    Licensee's control; and
(c) includes the following notice: "This is an implementation of
    an early-draft specification developed under the Java Community
    Process (JCP) and is made available for testing and evaluation
    purposes only. The code is not compatible with any specification
    of the JCP."

The grant set forth above concerning your distribution of
implementations of the specification is contingent upon your
agreement to terminate development and distribution of your
"early draft" implementation as soon as feasible following final
completion of the specification. If you fail to do so, the foregoing
grant shall be considered null and void. No provision of this
Agreement shall be understood to restrict your ability to make
and distribute to third parties applications written to the
Specification. Other than this limited license, you acquire no
right, title or interest in or to the Specification or any other
intellectual property of the Specification Lead, and the
Specification may only be used in accordance with the license terms
set forth herein. This license will expire on the earlier of:
(a) two (2) years from the date of Release listed above; (b) the
date on which the final version of the Specification is publicly
released; or (c) the date on which the Java Specification Request
(JSR) to which the Specification corresponds is withdrawn. In
addition, this license will terminate immediately without notice
from the Specification Lead if you fail to comply with any provision
of this license. Upon termination, you must cease use of or destroy
the Specification.

"Licensor Name Space" means the public class or interface
declarations whose names begin with "java", "javax", "com.oracle"
or their equivalents in any subsequent naming convention adopted
by Credit Suisse AG through the Java Community Process, or any
recognized successors or replacements thereof.

*TRADEMARKS*

No right, title, or interest in or to any trademarks, service
marks, or trade names of Credit Suisse AG or Credit Suisse AG's
licensors is granted hereunder. Oracle, the Oracle logo, Java
are trademarks or registered trademarks of Oracle USA, Inc. in
the U.S. and other countries.


*DISCLAIMER OF WARRANTIES*

THE SPECIFICATION IS PROVIDED "AS IS" AND IS EXPERIMENTAL AND
MAY CONTAIN DEFECTS OR DEFICIENCIES WHICH CANNOT OR WILL NOT BE
CORRECTED BY THE SPECIFICATION LEADS. THE SPECIFICATION LEADS MAKE
NO REPRESENTATIONS OR WARRANTIES, EITHER EXPRESS OR IMPLIED,
INCLUDING BUT NOT LIMITED TO, WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE, OR NON-INFRINGEMENT THAT THE
CONTENTS OF THE SPECIFICATION ARE SUITABLE FOR ANY PURPOSE OR
THAT ANY PRACTICE OR IMPLEMENTATION OF SUCH CONTENTS WILL NOT
INFRINGE ANY THIRD PARTY PATENTS, COPYRIGHTS, TRADE SECRETS OR
OTHER RIGHTS.

This document does not represent any commitment to release or
implement any portion of the Specification in any product.

THE SPECIFICATION COULD INCLUDE TECHNICAL INACCURACIES OR
TYPOGRAPHICAL ERRORS. CHANGES ARE PERIODICALLY ADDED TO THE
INFORMATION THEREIN; THESE CHANGES WILL BE INCORPORATED INTO
NEW VERSIONS OF THE SPECIFICATION, IF ANY. THE SPECIFICATION
LEADS MAY MAKE IMPROVEMENTS AND/OR CHANGES TO THE PRODUCT(S)
AND/OR THE PROGRAM(S) DESCRIBED IN THE SPECIFICATION AT ANY
TIME.

Any use of such changes in the Specification will be governed
by the then-current license for the applicable version of the
Specification.

*LIMITATION OF LIABILITY*

TO THE EXTENT NOT PROHIBITED BY LAW, IN NO EVENT WILL THE
SPECIFICATION LEADS AND/OR THEIR LICENSORS BE LIABLE FOR ANY
DAMAGES, INCLUDING WITHOUT LIMITATION, LOST REVENUE, PROFITS OR
DATA, OR FOR SPECIAL, INDIRECT, CONSEQUENTIAL, INCIDENTAL OR
PUNITIVE DAMAGES, HOWEVER CAUSED AND REGARDLESS OF THE THEORY OF
LIABILITY, ARISING OUT OF OR RELATED TO ANY FURNISHING, PRACTICING,
MODIFYING OR ANY USE OF THE SPECIFICATION, EVEN IF CREDIT SUISSE
AND/OR ITS LICENSORS HAVE BEEN ADVISED OF THE POSSIBILITY OF SUCH
DAMAGES.

You will hold the Specification Lead (and its licensors) harmless
from any claims based on your use of the Specification for any
purposes other than the limited right of evaluation as described
above, and from any claims that later versions or releases of any
Specification furnished to you are incompatible with the
Specification provided to you under this license.

*RESTRICTED RIGHTS LEGEND*

If this Software is being acquired by or on behalf of the U.S.
Government or by a U.S. Government prime contractor or subcontractor
(at any tier), then the Government's rights in the Software and
accompanying documentation shall be only as set forth in this license;
this is in accordance with 48 C.F.R. 227.7201 through 227.7202-4 (for
Department of Defense (DoD) acquisitions) and with 48 C.F.R. 2.101
and 12.212 (for non-DoD acquisitions)

*REPORT*

You may wish to report any ambiguities, inconsistencies or
inaccuracies you may find in connection with your evaluation of
the Specification ("Feedback"). To the extent that you provide
the Specification Lead with any Feedback, you hereby:
(i) agree that such Feedback is provided on a non-proprietary and
    non-confidential basis, and
(ii) grant the Specification Lead a perpetual, non-exclusive,
     worldwide, fully paid-up, irrevocable license, with the right
     to sublicense through multiple levels of sublicensees, to
     incorporate, disclose, and use without limitation the
     Feedback for any purpose related to the Specification and
     future versions, implementations, and test suites thereof.

*GENERAL TERMS*

Any action related to this Agreement will be governed by California
law and controlling U.S. federal law. The U.N. Convention for the
International Sale of Goods and the choice of law rules of any
jurisdiction will not apply. The Specification is subject to U.S.
export control laws and may be subject to export or import
regulations in other countries. Licensee agrees to comply strictly
with all such laws and regulations and acknowledges that it has
the responsibility to obtain such licenses to export, re-export or
import as may be required after delivery to Licensee. This Agreement
is the parties' entire a agreement relating to its subject matter.
It supersedes all prior or contemporaneous oral or written
communications, proposals, conditions, representations and
warranties and prevails over any conflicting or additional terms of
any quote, order, acknowledgment, or other communication between the
parties relating to its subject matter during the term of this
Agreement. No modification to this Agreement will be binding,
unless in writing and signed by an authorized representative of
each party.

:numbered:

<<<

== Introduction
This document is the specification of the Java EE API for Configuration. The technical objective is to provide a
unified configuration model in Java EE, targeted the whole EE platform.
The API will provide support for key/value based application configuration, as well as 'DevOps' related container
configuration. It will furthermore provide extension points for adding additional features, e.g. implementing higher
level APIs based on configuration.

=== Expert group
This work is being conducted as part of JSR {{jsrnumber}} under the Java Community Process. This specification is the
result of the collaborative work of the members of the JSR 354 Expert Group and the community at large. The following
persons have actively contributed to Java Money in alphabetical order:

* Werner Keil
* Simon Martinelli
* Laird Nelson (Oracle, Spec Lead)
* Anatole Tresch (Credit Suisse, Spec Lead)

=== Specification goals
Configuration is a key feature in Java EE, multiple deployment. blablabla.

==== Specification Targets
JSR 354 targets to support all general configuration aspects, e.g.

* spplication configuration
** plugins
** modules
** components
* Configuration of Java EE related aspect (Java enterprise application portability)
** Configuration of CDI, especially interceptors, decorators and alternatives
** Configuration of other JSRs is also targeted within EE 8 development. Though this JSR focuses on providing
   the necessary base mechanism for enabling other JSRs to be configured from alternate resources transparently.
* Container Configuration
** Some aspects of container configuration is also included, targeting important 'DevOps' aspects


[[Scope]]
=== Scope
JSR {{jsrversion}} targets a Java EE scope. The API must cover all EE specific configuration and application
configuration in a minimalistic way. Subsequent releases of this JSR may add additional aspects, when more evidence
and experience has been gathered.

=== Required Java version
The specification is based on Java SE 8.0 language features.

=== How this document is organized
There are five main section in this document:

* Use cases.
* Requirements.
* Specification.
* Implementation Recommendations.
* An appendix.

<<<

[[Use Cases]]
Use Cases
---------
This section describes some, but not all, of the use cases that should be covered with this JSR.

[[ScenarioSources]]
The configuration system in DeltaSpike uses, what they call, 'sources'  (http://deltaspike.apache.org/configuration
.html#configsource). Configuration hereby comes from several sources :

* System properties
* Environment properties
* JNDI values
* Properties file values (default filename is "META-INF/apache-deltaspike.properties")

These sources have a default priority (System first.... properties file last) that can be changed. So we could easily
say "by default, the 'WEB-INF/classes' directory is a source that has a priority higher that an external file". This
way, by default, if there is a config file within a war, it will have higher priority, meaning Java EE components will
behave as they use too. Get rid of this file from the war, then the following source (external file) will get into
account.
And of course, this default behavior can be changed

-> Configuration must be combinable
-> Configuration must have different priorities that may taken into account, when combining configuration.

[[ScenarioConfigurableOverrides}}
Overriding behavior configurable, e.g. refer to the way of the Jersey team. You can register components and given
them a priority. This approach would allow us to provide a default chain of sources of configuration properties and
to allow the user to specify his own chain.

-> Configuration is evaluated by a chain of responsibility
-> Different environments may require different chains

[[ScenarioMultiTenancy]]
In multi tenancy setups a hierarchical/graph model of contexts for configurations is required. For example there might
be some kind of layering:

* Layer 0: Default App configuration
* Layer 1: Tenant specific configuration
* Layer 2: User specific configuration

Configurations made in the tenant or user layer override the default app configuration etc.

-> Configuration must be orgainized in layers that can override/extend each other.
-> The current environment must be capable of mapping tenant, user and other aspects, so a corresponding configuration
   (or layer) can be derived.

[[ScenarioOperations]]
=== Scenario Operations
Currently support of Java EE for Operations (e.g. PaaS offerings) is weak. Also corresponding provider may not be fully
compatible, which makes it more difficult to move applications between providers or different offerings/products
within the same provider.  hereby a provider requires an extension to the EE runtime model, where all relevant
deployment configuration can be controlled by external source, managed by the provider and consumed by the EE platform.

Basically if one deploys a java application a standard way to define it's configuration, resources and environment
to integrate with the provisioning tooling in place should defined. Also there should be a standardized way
to evaluate a configuration for an already deployed application.

The configuration should be pluggable (e.g. from a database, an external file,...) and the configuration should
also be changeable at runtime.

-> EE deployments must be configurable. Configuration must be controllable from external sources, which are not
controlled by the EE container.

-> External resource can override all aspects, or only override/extend specific parts, but still consider
configuration data deployed with the application.

-> a contract is required, how this external configuration can be included/provided.

-> a contract is required, how according configuration is modelled, so the external source can "implement" the contract.

-> a service is required that allows to read out the configuration of a deployed application.

-> Configuration may be fully or partially mutable.

-> Changes on configuration must be observable.


[[ScenarioDeveloper]]
As a developper I want to be able to configure my application/module something like this :

[source, java]
----------------------------------------------------
public MyPojo {
  private String currency;
  private Long currencyRate;

  // complex algorithm based on the currency
}
----------------------------------------------------

How do I configure that depending if my app is dealing with dollars or euros ? The DeltaSpike way of doing is
something like :

[source, java]
----------------------------------------------------
public MyPojo {
  @Inject @Config("myCurrency")
  private String currency;
  @Inject @Config("myCurrencyRate")
  private Long currencyRate;

  // complex algorithm based on the currency
}
----------------------------------------------------

The Seam Config way of doing is quite clever. They use a namespace that is relative to the packing. So, without changing
the initial code (so, forget about the @Inject above) they have an XML file that is able to override each attribute of
any file.

As a Java EE user (developer or devops) I would like also to be able to package different versions of deployment
descriptor fragments within my Java EE application archive, and be able to select which one is used via a +-D+
command line argument.

E.g. have the following file structure within the application archive (a +.war+ in this case):

[source, listing]
----------------------------------------------------
WEB-INF
    conf
        dev
            web-fragment.xml
        qa
            web-fragment.xml
        live
            web-fragment.xml
----------------------------------------------------

And then either directly be able to say that +conf/dev/web-fragment.xml+ should be used, or do this indirectly via an
include directive and a placeholder in the main deployment descriptor for this type of fragment (in this case +web
.xml+):

[source, xml]
----------------------------------------------------
<web-app>
    ...
    <fragment>WEB-INF/conf/${mycompany.staging}/web-fragment.xml</fragment>
</web-app>
----------------------------------------------------

-> Application Configuration must be supported.

-> Configuration must be injectable using CDI

-> Configuration should support fragements, which can dynamically loaded by properties on the current runtime
environment.

[[ScenarioModules]]
=== Scenario Modules
Complex applications are often built out of many more fine granular pieces, often called modules or plugins. This
could be technical abstractions, business models, products or UI components. All of them require some configuration,
which may be different for different runtime deployments (e.g. product customizations).

-> it must be possible to add configuration that exceeds the EE deployment aspects (Application Configuration).

-> this configuration must be deployable in different ways, along the code, or from external sources.

[[ScenarioTesting]]
=== Scenario Testing
When testing a Java EE solution, it must be possible to easily control the configuration provided, so isolated
component tests can be written effectively. Also it should be possible to control/isolate the configuration level for
each test case.

-> isolation of configuration services

-> API for controlling the configuration provided, required for according implementations in the testing frameworks.

[[ScenarioStaging]]
=== Scenario Staging
Different companies go through different staging levels during the development of software components. Currently only
rarely the EE frameworks support staging aspects, nevertheless no broader, well modelled staging concept is defined.
Different companies also have different staging or sub-staging levels in place, which also must be reflected.
Especially with sub-stages inheritance of stage related configuration is common sense and should be supported.

-> Main stages available and to be supported by Java EE must be defined.

-> Enable sub-stages, additional aspects to be added, so also custom stages can be supported by configuration.

-> Allow stage properties inheritance, where needed.

[[ScenarioCotsIntegration]]
=== Custom of the Shelf (COTS) Integration
When buying software from an external software company it is often very cumbersome to integrate, adapt and customize
third party software to the internal operational requirements. Especially, when software is delivered as ear modules
portability is often very difficult and time consuming. Configuration should enable COTS providers to define a
customization contract, which also can be part of the COTS software interface and integration specifications. This
would allow operations to better control and configure third party solutions as possible, whereas in the evaluation
phase the integration and configuration options can explicitly be defined.

-> It must be possible to document configuration aspects supported.

-> It must be possible to configure arbitrary aspects, with basically arbitrary complexity, exceeding what is defined
   by Java EE.

-> Configuration must be overridable from external sources (the operations which must operate the COTS solution).

[[ScenarioAutoDeployment]]
When operating huge server farms targeting Java EE solutions a typical process is as follows:

. An order for a Java EE deployment is created.
. An according logical domain is created and prepared image with a standard setup is installed.
. The logical domain and the containing Java EE application server are started in standalone mode.
. The application(s) are copied to the server and automatically deployed.

Hereby it would ease life of administrators, if deployment of EE solutions can be controlled/automated by the
application server. This requires that the application server can be startup in some "maintenance mode", which allows
to trigger its configuration service, so according deployments can be controlled by some (external) deployment
controller.

-> Configuration must be injectable/deployable also into a running application server.

-> It must be possible to listen to configuration changes, so the deployment could be controlled similarly based
   on configuration changes (events).

-> configuration must be mutable and changes observable.

<<<

[[RequirementsCore]]
Requirements
------------
=== Core Configuration Requirements
Based on the scope and use cases described above the following core requirements can be identified:

. Req1
. Req2

[[RequirementsServer]]
=== Server Configuration Requirements
shskjdhskhds sdkj ksjdks skjdskjd:

. Req1
. Req2

[[RequirementsExtensions]]
=== Extensions Requirements
shskjdhskhds sdkj ksjdks skjdskjd:

. Req1
. Req2

[[RequirementsNonFunctional]]
=== Non Functional Requirements
. Req1
. Req2

[[Specification]]
Specification
-------------
=== Package and Project Structure
==== Package Overview
The JSR defines two packages:

+javax.config+:: contains the main artifacts, such as +Environment, Configuration, PropertyMap, ConfigurationAdjuster,
ConfigurationQuery+, and the service interfaces +EnvironmentManager, ConfigurationManager+.

+javax.config.spi+:: contains the <<SPI>> interfaces provided by the JSR {{jsrversion}} API.

[[Modules]]
==== Module/Repository Overview
The JSR’s source code repository under [<<source>>] provides several modules:

configuration-api:: contains the JSR {jsrNumber} API as described also be this specification.
configuration-ri:: contains the reference implementation.
configuration-tck:: contains the technical compatibility kit (TCK).
configuration-parent:: is a root “POM” project for all modules under +org.javaconfig+. This includes the RI/TCK
projects, but not javaconfig-api.
configuration-examples:: finally contains the examples and demos, and also is not part of this JSR.

[[CoreAPI]]
=== Configuration Core API

The following sections will describe these artifacts in more detail.

[[ModellingConfiguration]]
==== Modeling of Configuration

Basically configuration is a very generic concept. Therefore it should be modelled in a generic way. The most simple
and similarly most commonly used are simple literal key/value pairs. Using Strings as base representation of
configuration comes with several huge advantages:

* Strings are simple to understand
* Strings are human readable and therefore easy to prove for correctness
* Strings can easily be used within different language, different VMs, files or network communications.
* Strings can easily be compared and manipulated
* Strings can easily be searched, indexed and cached
* It is very easy to provide Strings as configuration, which gives much flexibility for providing configuration in
  production as well in testing.
* and more

On the other side there are also disadvantages:

* Strings are inherently not type safe, they do not provide validation out of the box for special types, such as
numbers,
  dates etc.
* Often you want not to work with Strings, but with according types.
* Strings are not hierarchical, so mapping hierarchical structures requires some extra efforts.

Nevertheless most of these advantages can be mitigated easily, hereby still keeping all the benefits from above:

* Adding type safe converters on top of String allow to add any type easily, that can be directly mapped out of Strings.
  This includes all common base types such as numbers, dates, time, but also timezones, formatting patterns and more.
* Even more complex mappings can be easily realized, by using String not as a direct representation of configuration,
  but a reference that defines where the more complex configuration artifact is available. This mechanism is similarly
  easy to understand as parsing Strings to numbers, but is powerful enough to provide e.g. all kind of deployment
  descriptors in Java EE.
* Hierarchical and collection types can be mapped in different ways:
** The keys of configuration can have additional syntax/semantics. E.g. when adding dor-separating path semantics
*** trees/maps can also simply be mapped:

[source,properties]
.Using hierarchical keys to model a tree
--------------------------------------------
          a
      /      \
   a1=a1Value a2
               \
                a21=a21Value
--------------------------------------------

modelled as properties...

[source,properties]
.Using hierarchical keys to model a tree/map
--------------------------------------------
   a
   a.a1=a1Value
   a.a2
   a.a2.a21
--------------------------------------------

   Hereby it is not necessary to add all keys, only the one that have values must be provided, so the following entries
   basically define the same tree

[source,properties]
.Using hierarchical keys to model a tree (cont.)
--------------------------------------------
   a.[type]=map
   a.a1=a1Value
   a.a2.a21=a21Value
--------------------------------------------


*** list basically can also be mapped:

[source,properties]
.Using hierarchical keys to model a list
--------------------------------------------
   a=a1,a2,a3,a4,a0
--------------------------------------------

modelled as properties...

[source,properties]
.Using hierarchical keys to model a tree/map
--------------------------------------------
   a.[type]=list
   # optional
   # a.[comparator]=my.ComparatorClass
   a.[children]=a1,a2,a3,a4,a0
--------------------------------------------

==== Property Maps

We have seen that constrain configuration aspects to simple literal key/value pairs provides us with an easy to
understand, generic, flexible, yet extendible mechanism. Looking at the Java language features a +vava.util.Map<String,
String>+ and +java.util.Properties+ basically model these quite well out of the box.
So it makes sense to build configuration on top of the JDK's +Map+ interface. This creates immediately additional
benefits:

* we inherit full Lambda and collection support
* Maps are widely known and well understood

Nevertheless there are some things to be considered:

* Configuration also requires meta-data, such as
** the origin of a certain configuration entry
** the sensitivity of some data
** the provider that have read the data
** the time, when the data was read
** the timestamp, when some data may be outdated
** ...

Basically the same is also the not related to some single configuration key, but also to a whole map.
The +PropertyMap+ interface models exact these aspects and looks as illustrated below:

[source,java]
.Interface PropertyMap
--------------------------------------------
public interface PropertyMap extends Map<String,String>{
  Map<String,String> getMetaInfo(String key);
  Map<String,String> getMetaInfo();
  ConfigChange reload();
  boolean isMutable();
}
--------------------------------------------

Hereby

* +getMetaInfo()+ return the meta information for the whole property map
* +getMetaInfo(String)+ returns meta information for the a specific key in the property map
* +isMutable()+ allows to easy check, if a property map is mutable, which is more elegant than catching
  +NonSupportedOperation+ exception thrown on the acording methods of +Map+.
* +reload()+ finally allows to reload a property map. It depenends on the implementing source, if this operation
  has some effect. If the map changes an according +ConfigChange+ must be returned, describing the
  changes applied.

This simple model will be used within the spi, where configuration can be injected/provided from external resources.
But we have seen, that we have to consider additional aspects, such as extendability and type safety. Therefore we
extend +PropertyMap+ and hereby also apply the 'composite pattern', which results in the following key abstraction.

==== Configuration

Configuration inherits all basic features from +PropertyMap+, but additionally adds additional functionality for
type safety and extension mechanisms:

[source,java]
.Interface Configuration
--------------------------------------------
public interface Configuration extends PropertyMap{
  Boolean getBoolean(String key);
  Boolean getBooleanOrDefault(String key, Boolean defaultValue);
  Byte getByte(String key);
  Byte getByteOrDefault(String key, Byte defaultValue);
  Short getShort(String key);
  Short getShortOrDefault(String key, Short defaultValue);
  Integer getInteger(String key);
  Integer getIntegerOrDefault(String key, Integer defaultValue);
  Long getLong(String key);
  Long getLongOrDefault(String key, Long defaultValue);
  Float getFloat(String key);
  Float getFloatOrDefault(String key, Float defaultValue);
  Double getDouble(String key);
  Double getDoubleOrDefault(String key, Double defaultValue);
  <T> T getAdapted(String key, PropertyAdapter<T> adapter);
  <T> T getAdaptedOrDefault(String key, PropertyAdapter<T> adapter, T defaultValue);
  <T> T getOrDefault(String key, Class<T> type, T defaultValue);
  <T> T get(String key, Class<T> type);
  Set<String> getAreas();
  Set<String> getTransitiveAreas();
  Set<String> getAreas(Predicate<String> predicate);
  Set<String> getTransitiveAreas(Predicate<String> predicate);
  boolean containsArea(String key);
  Configuration with(ConfigurationAdjuster adjuster);
  <T> T query(ConfigurationQuery<T> query);
}
--------------------------------------------

Hereby

* +XXX getXXX(String)+ and +XXX getXXXOrDefault(String, XXX)+ provide type safe accessors for all basic wrapper types
  of the JDK.
* +getAdapted, getAdaptedOrDefault()+ allow accessing any type, hereby also passing a +PropertyAdapter+ that converts
  the configured literal value to the type required.
* +get(String, Class)+ and +getOrDefault(String, Class<T>, T)+ similarly allow type safe access of any type, but are
  using predefined registered +PropertyAdapter+ instances (shown later in this document).
* +getAreas()+, +getTransitiveAreas()+ allow to examine the hierarchical tree modeled by the configuration tree.
  Optionally also predicates can be passed to select only part of the tree to be returned.
* +containsArea+ allows to check, if an area is defined.
* +with, query+ provide the extension points for adding additional functionality.

==== ConfigurationManager

The configuration manager provides access to configurations, currently available. It is accessible from JNDI under
+comp:/env/ConfigurationManager+:

[source,java]
.Interface Configuration
--------------------------------------------
public interface ConfigurationManager{
  Configuration getConfiguration();
  Configuration getConfiguration(Environment environment);
}
--------------------------------------------

Hereby

* +getConfiguration()+ return the configuration valid for the current runtime environment.
* +getConfiguration(Environment environment);+ allows to access configuration for s specific environment, e.g.
  for an enterprise application that is not yet deployed.

The configuration manager hereby must be accessible also during server startup, so it can be used by components that
configure the server itself.

So it is time, that we look at the +Environment+ abstraction in more detail.

==== Environment

The environment basically is also a simple +Map<String,String>+ similar to +System.getProperties()+ and +System
.getenv()+ in the JDK. Nevertheless it provides additional functionality:

* environments are hierarchical. Hereby all environments inherit from the root environment. The root environment
  hereby must contain
  ** all JDK's system properties, with same keys, values
  ** all JDK's environment properties, prefixed with +env:+.
  ** additionaly root properties as needed.
* each environment also defines its +Stage+. Hereby, if not set explicitly the +Stage+ is inherited from the root
  environment. Consequently the root environment must provide a +Stage+, which by default should be +Stage.Development+.


==== EnvironmentManager

Similar to the configuration manager the +EnvironmentManager+ provides programmatic access to the current environment
and the root environment. It is accessible from JNDI under +comp:/env/EnvironmentManager+:

[source,java]
.Interface EnvironmentManager
--------------------------------------------
public interface EnvironmentManager{
  Environment getCurrentEnvironment();
  Environment getRootEnvironment();
}
--------------------------------------------

The environment manager hereby must be accessible also during server startup, so it can be used by components that
configure the server itself.

==== Configuration Metamodel

The configuration that is loaded and provided can be built up and combined arbitrarely. Hereby it is possible to
combine multiple +PropertyMap+ instances into higher level aggregates. Depending on the current active environment
certain +PropertyMap+ instances may not be active, which make them behave as they were not there at all. Also
different maps can be combined using set operations such as union, subtraction or intersection. In case of conflicts
different resolution strategies can be applied:

* +OVERRIDE+ replaces any former conflicting value by the value read the latest, when building up the configutation map.
* +IGNORE+ uses the first non null value and ignores all subsequent values found during configuration map build up.
* +EXCEPTION+ throws a +ConfigException+ and handles duplicates as 'deployment problems'.
* +CUSTOM+ allows to register a custom +ResolutionStrategy+, which must handle the conflict.

Regarding the combinations of property maps, the following types are supported:

* +UNION+ simply creates a new +PropertyMap+ containing values from both child maps. If a key is not unique an
according resolution strategy (see above) must be applied. The default resolution strategy hereby is +OVERRIDE+.
* +INTERSECT+ combines two instance of +PropertyMap+ containing only keys, ta^hat are present in both child maps.
Since all key intersect, a resolution strategy (see above) must be applied. The default resolution strategy hereby is
 +FIRST+, which will take the values from the first map participating in the operation.
* +DISTINCT+ combines two maps, but only contains keys, that are present in exact one map. Since no intersection is
  possible this strategy does not need any resolution strategy.

As mentioned a +PropertyMap+ can be selectively active depending on the current runtime +Environment+. Toa chieve this
a +Predicate<Environment>+ can be registered with each +PropertyMap+.

Summarizing a configuration meta model can be defined as:

* a number of +Configuration+ instances, that are built based on a set of +PropertyMap+ instances.
* a +PropertyMap+ can be directly implemented.
* a +PropertyMap+ can be a combination of other +PropertyMap+ instances (composite pattern), whereas possible
combinations are
  ** +UNION, INTERSECT, DISTINCT+
  ** in case of conflicts the following resolution policies can be used:
  *** +OVERRIDE, IGNORE, EXCEPTION, CUSTOM+
* on a +PropertyMap+ also a ordered list of +UnaryOperator<PropertyMap>+ can be applied. This is useful for
** filtering a map
** mapping some keys
** logging the entries in the map
** ...

Whereas several libraries use 'XML' for configuring things like this in EE 8 we can fortunately use CDI for doing
the wiring of the different components without having to write any XML code. For example an instance of +ProeprtyMap+
can simply be declared as a CDI bean:

[source,java]
.A simple PropertyMap
--------------------------------------------
@Singleton @FooConfigMap                            <1>
public class MyPropertyMap implements PropertyMap{
  ...
}
--------------------------------------------
<1> @FooConfigMap is a CDI qualifier

The weiring can be controlled by adding corresponding annotations that are triggering the according property map
factories, e.g. for creating a combined Map, you could use the union factory:

[source,java]
.A simple PropertyMap union
--------------------------------------------
@Singleton
public class MyPropertyMap implements PropertyMap{
  @ConfigUnion
  @Map(@Named("myName"))
  @Map(@FooConfigMap)
  private PropertyMap unionMap;
  ...
}
--------------------------------------------

Also additional functionality such as adding operators, explicit resolution policies etc can be applied similarly:

[source,java]
.A customized PropertyMap distinct set
--------------------------------------------
@Singleton
@ConfigUnion(UnionType.DISTINCT)                            <1>
@ConfigResolutionPolicy(policy=ResolutionPolicy.CUSTOM, class=MyResolvePol.class)
@Map(@Named("myName"))                                      <2>
@Map(@FooConfigMap)                                         <2>
public abstract class MyPropertyMap implements PropertyMap{
  // empty
}
--------------------------------------------
<1> CDI Decorator
<2> Java 8 compatible multiple annotations, defining the order of assembly

Finally +Configuration+ can be composed similarly:

[source,java]
.An example Configuration Definition
--------------------------------------------
@Singleton
@FooConfig                                                  <1>
@ConfigUnion(UnionType.DISTINCT)                            <2>
@ConfigResolutionPolicy(policy=ResolutionPolicy.CUSTOM, class=MyResolvePol.class)
@Map(@Named("myName"))                                      <3>
@Map(@FooConfig)                                            <3>
public abstract class MyConfig implements Configuration{
   // empty                                                 <4>
}
--------------------------------------------
<1> CDI Qualifier
<2> CDI Decorator
<3> Java 8 compatible multiple annotations
<4> Body can be left empty since decorator will provide implementation

===== Additional Features

The metamodel presented in the last section is very flexible, but still some additional features are required.

* Filtering of any configuration using Expression Language is possible (for more details refer to the EL section). For
  this the +<map>+ definition must be extended:

[source,java]
--------------------------------------------
@Singleton @FooConfig
@ConfigELEnabled
public final class MyPropertyMap implements PropertyMap{
  ...
}
--------------------------------------------

* As mentioned earlier in this specification, it is possible to activate/deactivate property maps based on the current
  +Environment+. This can be achieved by configuring a fully qualified class implementing +Predicate<Environment>+ to
  the +<map>+ configuration:

[source,java]
--------------------------------------------
@Singleton @FooConfig
@ConfigMapActivator(foo.bar.MyActivator.class)
public final class MyPropertyMap implements PropertyMap{
  ...
}
--------------------------------------------

* A map can have a priority. If multiple maps with the same name are configured, the map with the highest priority
  replaces all other maps. If more than one map configuration qualifies, it is handled as a deployment error and a
  +ConfigException+ is thrown.

[source,java]
--------------------------------------------
@Singleton @FooConfig
@ConfigELEnabled
@Priority(10)
public final class MyPropertyMap implements PropertyMap{
  ...
}
--------------------------------------------


:numbered!:
== APPENDIX
=== XML Based Meta-Configuration

The configuration that is loaded and provided can be built up and combined arbitrarily. Hereby it is possible to
combine multiple +PropertyMap+ instances into higher level aggregates. Depending on the current active environment
certain +PropertyMap+ instances may not be active, which make them behave as they were not there at all. Also
different maps can be combined using set operations such as union, subtraction or intersection. In case of conflicts
different resolution strategies can be applied:

* +OVERRIDE+ replaces any former conflicting value by the value read the latest, when building up the configutation map.
* +IGNORE+ uses the first non null value and ignores all subsequent values found during configuration map build up.
* +EXCEPTION+ throws a +ConfigException+ and handles duplicates as 'deployment problems'.
* +CUSTOM+ allows to register a custom +ResolutionStrategy+, which must handle the conflict.

Regarding the combinations of property maps, the following types are supported:

* +UNION+ simply creates a new +PropertyMap+ containing values from both child maps. If a key is not unique an
according resolution strategy (see above) must be applied. The default resolution strategy hereby is +OVERRIDE+.
* +INTERSECT+ combines two instance of +PropertyMap+ containing only keys, ta^hat are present in both child maps.
Since all key intersect, a resolution strategy (see above) must be applied. The default resolution strategy hereby is
 +FIRST+, which will take the values from the first map participating in the operation.
* +DISTINCT+ combines two maps, but only contains keys, that are present in exact one map. Since no intersection is
  possible this strategy does not need any resolution strategy.

As mentioned a +PropertyMap+ can be selectively active depending on the current runtime +Environment+. Toa chieve this
a +Predicate<Environment>+ can be registered with each +PropertyMap+.

Summarizing a configuration meta model is defined as:

* a number of +Configuration+ instances, that are built based on a set of +PropertyMap+ instances.
* a +PropertyMap+ can be directly implemented.
* a +PropertyMap+ can be a combination of other +PropertyMap+ instances (composite pattern), whereas possible
combinations are
  ** +UNION, INTERSECT, DISTINCT+
  ** in case of conflicts the following resolution policies can be used:
  *** +OVERRIDE, IGNORE, EXCEPTION, CUSTOM+
* on a +PropertyMap+ also a ordered list of +UnaryOperator<PropertyMap>+ can be applied. This is useful for
** filtering a map
** mapping some keys
** logging the entries in the map
** ...

Finally we are able to define a configuration meta-model in +configuration.xml+ as follows:

TODO:
-------
Where to store configuration.xml? How about multiple locations?
-------

[source,xml]
.Example Meta-Configuration
--------------------------------------------
<?xml version="1.0" encosing="utf-8"?>
<config>
  <properties>
     <map id="Foo1" class="foo.bar.MyPropertyMapImpl"/>
     <map id="myEnvView">
       <union resolution="OVERRIDE">
         <operators>
           <operator>foor.bar.MyEnvViewFilter</operator>
         </operators>
         <members>
           <map ref="ENVIRONMENT" />
           <map ref="SYSTEM" />
           <map ref="ARGS" />
         </members>
       </union>
     </map>
  </properties>
  <configurations>
    <configuration id="FooConf">
      <union resolution="CUSTOM" resolutionPolicy="foor.bar.MyResolutionPolicyClass" >
        <members>
          <map ref="myEnvView" />
          <map ref="Foo1" />
        </members>
      </union>
    </configuration>
  </configurations>
</config>
--------------------------------------------

===== Additional Features

The metamodel presented in the last section is very flexible, but still some additional features are required.

* Filtering of any configuration using Expression Language is possible (for more details refer to the EL section). For
  this the +<map>+ definition must be extended:

[source,xml]
--------------------------------------------
  ...
  <map id="Foo1" ...  elEnabled="true"/>
--------------------------------------------

* As mentioned earlier in this specification, it is possible to activate/deactivate property maps based on the current
  +Environment+. This can be achieved by configuring a fully qualified class implementing +Predicate<Environment>+ to
  the +<map>+ configuration:

[source,java]
--------------------------------------------
@Named("Foo1")
@MapActivator(foo.bar.MyActivator.class)
public final class MyPropertyMap implements PropertyMap{
  ...
}
--------------------------------------------

* A map can have a priority. If multiple maps with the same name are configured, the map with the highest priority
  replaces all other maps. If more than one map configuration qualifies, it is handled as a deployment error and a
  +ConfigException+ is thrown.

[source,xml]
--------------------------------------------
  ...
  <map id="Foo1" ...  prio="10"/>
--------------------------------------------

* In the complete meta-configuration example we used explicit ids for maps. This allows to reuse map instances by
  referencing them using these ids. Nevertheless it is also possible to built up the configuration tree implicitly:

[source,xml]
--------------------------------------------
  <map id="myEnvView">
    <union resolution="OVERRIDE">
      <members>
        <map class="MyMap1" />
        <map class="MyMap2" />
        <map class="MyMap3" />
      </members>
    </union>
  </map>
--------------------------------------------

* Finally maps can also be configured:

[source,xml]
--------------------------------------------
  <map id="Foo1" class="foo.bar.MyPropertyMapImpl">
    <configuration>
      <property name="name">MyFoo</property>
      <property name="totalRuns">200</property>
    </configuration>
  </map>
--------------------------------------------